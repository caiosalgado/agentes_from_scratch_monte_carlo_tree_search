{
  "problems": [
    {
      "id": "isPalindrome",
      "title": "Palindrome Number",
      "description": "Given an integer x, return true if x is a palindrome, and false otherwise.\\n\\nInput: An integer x\\nOutput: A boolean (true if palindrome, false otherwise)",
      "constraints": "-2^31 <= x <= 2^31 - 1",
      "function_signature": "def isPalindrome(x: int) -> bool:",
      "initial_code": "def isPalindrome(x: int) -> bool:\n    # Your solution here\n    pass",
      "tests": [
        {"input": [121], "expected": true},
        {"input": [-121], "expected": false},
        {"input": [10], "expected": false}
      ]
    },
    {
      "id": "romanToInt",
      "title": "Roman to Integer", 
      "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Given a roman numeral, convert it to an integer.\\n\\nInput: A string s representing a roman numeral\\nOutput: An integer representing the converted value",
      "constraints": "1 <= s.length <= 15, s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M')",
      "function_signature": "def romanToInt(s: str) -> int:",
      "initial_code": "def romanToInt(s: str) -> int:\n    # Your solution here\n    pass",
      "tests": [
        {"input": ["III"], "expected": 3},
        {"input": ["LVIII"], "expected": 58},
        {"input": ["MCMXCIV"], "expected": 1994},
        {"input": ["IV"], "expected": 4},
        {"input": ["IX"], "expected": 9}
      ]
    },
    {
      "id": "twoSum",
      "title": "Two Sum",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.\\n\\nInput: A list of integers nums and an integer target\\nOutput: A list of two integers representing the indices",
      "constraints": "2 <= nums.length <= 10^4, -10^9 <= nums[i] <= 10^9, -10^9 <= target <= 10^9, Only one valid answer exists",
      "function_signature": "def twoSum(nums: List[int], target: int) -> List[int]:",
      "initial_code": "from typing import List\n\ndef twoSum(nums: List[int], target: int) -> List[int]:\n    # Your solution here\n    pass",
      "tests": [
        {"input": [[2, 7, 11, 15], 9], "expected": [0, 1]},
        {"input": [[3, 2, 4], 6], "expected": [1, 2]},
        {"input": [[3, 3], 6], "expected": [0, 1]}
      ]
    },
    {
      "id": "addTwoNumbers",
      "title": "Add Two Numbers",
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\\n\\nInput: Two ListNode objects (l1, l2) representing linked lists\\nOutput: A ListNode object representing the sum as a linked list\\nNote: For testing purposes, input/output arrays represent linked lists",
      "constraints": "The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9. It is guaranteed that the list represents a number that does not have leading zeros.",
      "function_signature": "def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:",
      "initial_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:\n    # Your solution here\n    pass",
      "tests": [
        {"input": [[2, 4, 3], [5, 6, 4]], "expected": [7, 0, 8]},
        {"input": [[0], [0]], "expected": [0]},
        {"input": [[9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9]], "expected": [8, 9, 9, 9, 0, 0, 0, 1]}
      ]
    },
    {
      "id": "longestPalindrome",
      "title": "Longest Palindromic Substring",
      "description": "Given a string s, return the longest palindromic substring in s.\\n\\nInput: A string s\\nOutput: A string representing the longest palindromic substring",
      "constraints": "1 <= s.length <= 1000, s consist of only digits and English letters.",
      "function_signature": "def longestPalindrome(s: str) -> str:",
      "initial_code": "def longestPalindrome(s: str) -> str:\n    # Your solution here\n    pass",
      "tests": [
        {"input": ["babad"], "expected": "bab"},
        {"input": ["cbbd"], "expected": "bb"}
      ]
    },
    {
      "id": "maxArea",
      "title": "Container With Most Water",
      "description": "Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with the x-axis forms a container, such that the container contains the most water.\\n\\nInput: A list of integers height representing the heights of vertical lines\\nOutput: An integer representing the maximum area of water that can be contained",
      "constraints": "2 <= height.length <= 10^5, 0 <= height[i] <= 10^4",
      "function_signature": "def maxArea(height: List[int]) -> int:",
      "initial_code": "from typing import List\n\ndef maxArea(height: List[int]) -> int:\n    # Your solution here\n    pass",
      "tests": [
        {"input": [[1,8,6,2,5,4,8,3,7]], "expected": 49},
        {"input": [[1,1]], "expected": 1}
      ]
    },
    {
      "id": "mergeKLists",
      "title": "Merge k Sorted Lists",
      "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.\\n\\nInput: A list of ListNode objects representing k sorted linked lists\\nOutput: A ListNode object representing the merged sorted linked list\\nNote: For testing purposes, input/output arrays represent linked lists",
      "constraints": "k == lists.length\\n0 <= k <= 10^4\\n0 <= lists[i].length <= 500\\n-10^4 <= lists[i][j] <= 10^4",
      "function_signature": "def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:",
      "initial_code": "from typing import List, Optional\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n    # Your solution here\n    pass",
      "tests": [
        {
          "input": [[[1,4,5],[1,3,4],[2,6]]],
          "expected": [1,1,2,3,4,4,5,6]
        },
        {
          "input": [[]],
          "expected": []
        },
        {
          "input": [[[]]],
          "expected": []
        }
      ]
    },
    {
      "id": "findMedianSortedArrays",
      "title": "Median of Two Sorted Arrays",
      "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\\n\\nInput: Two lists of integers nums1 and nums2 (both sorted)\\nOutput: A float representing the median of the combined arrays",
      "constraints": "nums1.length == m\\nnums2.length == n\\n0 <= m, n <= 1000\\n1 <= m + n <= 2000\\n-10^6 <= nums1[i], nums2[i] <= 10^6",
      "function_signature": "def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:",
      "initial_code": "from typing import List\n\ndef findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:\n    # Your solution here\n    pass",
      "tests": [
        {
          "input": [[1, 3], [2]],
          "expected": 2.0
        },
        {
          "input": [[1, 2], [3, 4]],
          "expected": 2.5
        }
      ]
    },
    {
      "id": "isMatch",
      "title": "Regular Expression Matching",
      "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\\n- '.' Matches any single character.\\n- '*' Matches zero or more of the preceding element.\\nThe matching should cover the entire input string (not partial).\\n\\nInput: A string s (input text) and a string p (pattern)\\nOutput: A boolean indicating whether the entire string matches the pattern",
      "constraints": "1 <= s.length <= 20\\n1 <= p.length <= 30\\ns contains only lowercase English letters.\\np contains only lowercase English letters, '.', and '*'.\\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
      "function_signature": "def isMatch(s: str, p: str) -> bool:",
      "initial_code": "def isMatch(s: str, p: str) -> bool:\n    # Your solution here\n    pass",
      "tests": [
        {
          "input": ["aa", "a"],
          "expected": false
        },
        {
          "input": ["aa", "a*"],
          "expected": true
        },
        {
          "input": ["ab", ".*"],
          "expected": true
        }
      ]
    }
  ]
}